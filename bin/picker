#!/usr/bin/env bash

set -euo pipefail

# Show help message
show_help() {
    cat <<'EOF'
picker - A minimal TUI picker for selecting from piped input

USAGE:
    picker [--help]

DESCRIPTION:
    Reads lines from stdin and presents them as a numbered list for interactive
    selection. The selected line is printed to stdout.

    Full TUI compatibility: works perfectly inside editors like Helix and other
    terminal applications that redirect stdin/stdout.
    Press 'q' at any time to cancel without selecting.

EXAMPLES:
    # Basic usage
    ls | picker

    # Use with other commands
    git branch | picker | xargs git checkout

    # Use as fallback in scripts
    command | fzf || command | picker

OPTIONS:
    --help    Show this help message and exit

EXIT STATUS:
    0    A line was successfully selected
    1    Invalid selection or error occurred
    130  Canceled by user (pressed 'q')
EOF
}

# Function to check if stdin/stdout is a TTY and open /dev/tty if needed
setup_tty() {
    # Check if stdin is a TTY
    if [[ -t 0 ]]; then
        # stdin is a TTY, use it directly
        INPUT_FD=0
    else
        # stdin is redirected (e.g., from Helix), open /dev/tty for input
        exec 3</dev/tty
        INPUT_FD=3
    fi

    # For output, always use /dev/tty if stdin is not a TTY (following yazi's approach)
    # This ensures we can display the UI even when stdout is captured by the parent TUI
    if [[ -t 0 ]]; then
        # Normal execution, use stdout
        OUTPUT_FD=1
    else
        # Running inside a TUI app, use /dev/tty for output
        exec 4>/dev/tty
        OUTPUT_FD=4
    fi
}

# Read all input into an array
read_input() {
    # Read piped stdin into a global array
    PICKER_ITEMS=()
    local line
    while IFS= read -r line; do
        PICKER_ITEMS+=("$line")
    done
}

# Save and restore terminal settings
save_terminal_state() {
    if [[ "$INPUT_FD" != "0" ]] || [[ "$OUTPUT_FD" != "1" ]]; then
        # We're using /dev/tty, need to manage its state
        SAVED_STTY=$(stty -g </dev/tty 2>/dev/null) || SAVED_STTY=""
    fi
}

restore_terminal_state() {
    if [[ -n "${SAVED_STTY:-}" ]]; then
        stty "$SAVED_STTY" </dev/tty 2>/dev/null || true
    fi
}

# Display numbered lines and prompt for selection
display_and_select() {
    # Save terminal state before modifying it
    save_terminal_state

    # Set up terminal for interactive use when using /dev/tty
    if [[ "$INPUT_FD" != "0" ]]; then
        # Put terminal in raw mode for proper input handling
        stty raw -echo </dev/tty 2>/dev/null || true
    fi

    # Clear screen and display numbered lines
    printf '\033[2J\033[H' >&"$OUTPUT_FD"

    for i in "${!PICKER_ITEMS[@]}"; do
        printf '%3d: %s\r\n' $((i + 1)) "${PICKER_ITEMS[i]}" >&"$OUTPUT_FD"
    done

    printf '\r\nSelect a line number (1-%d) [q to cancel]: ' "${#PICKER_ITEMS[@]}" >&"$OUTPUT_FD"

    # Read selection from appropriate input
    local selection=""
    local char

    # Read input character by character until enter is pressed
    while IFS= read -r -n1 char <&"$INPUT_FD"; do
        if [[ "$char" == $'\r' ]] || [[ "$char" == $'\n' ]] || [[ "$char" == "" ]]; then
            printf '\r\n' >&"$OUTPUT_FD"
            break
        elif [[ "$char" == 'q' ]]; then
            # User canceled with 'q'
            printf '\r\n' >&"$OUTPUT_FD"
            exit 130
        elif [[ "$char" =~ [0-9] ]]; then
            selection+="$char"
            printf '%s' "$char" >&"$OUTPUT_FD"
        elif [[ "$char" == $'\177' ]] || [[ "$char" == $'\b' ]]; then
            # Backspace
            if [[ -n "$selection" ]]; then
                selection="${selection%?}"
                printf '\b \b' >&"$OUTPUT_FD"
            fi
        fi
    done

    # Restore terminal state
    restore_terminal_state

    # Validate selection
    if [[ "$selection" =~ ^[0-9]+$ ]] && ((selection >= 1 && selection <= ${#PICKER_ITEMS[@]})); then
        # Print selected line to stdout (original stdout, not TTY)
        printf '%s\n' "${PICKER_ITEMS[$((selection - 1))]}"
    else
        printf 'Invalid selection\n' >&2
        exit 1
    fi
}

# Cleanup function
cleanup() {
    restore_terminal_state
    # Close file descriptors if they were opened
    [[ "${INPUT_FD:-}" != "0" ]] && exec 3<&- 2>/dev/null || true
    [[ "${OUTPUT_FD:-}" != "1" ]] && exec 4>&- 2>/dev/null || true
}

# Set up signal handlers for cleanup
trap cleanup EXIT INT TERM

# Main execution
main() {
    # Check for help flag
    if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
        show_help
        exit 0
    fi

    setup_tty
    read_input
    display_and_select
}

main "$@"
